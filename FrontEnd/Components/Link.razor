@using PlaidQuickstartBlazor.Shared
@inject ContextContainer context
@inject HttpClient Http
@inject IJSRuntime JS

@*
    LINK BUTTON

    Manages the Plaid Link control
    https://plaid.com/docs/link/web/

*@

<div data-test-id="Link">
    @if (IsReady)
    {
        if (IsFixingToken)
        {
            <button type="button" class="btn btn-outline-secondary" @onclick="LaunchLink">
              Fix Token &raquo;
            </button>            
        }
        else
        {
            <button type="button" class="btn btn-primary" @onclick="LaunchLink">
              Launch Link &raquo;
            </button>
        }
    }
    else
    {
        @*
            TODO: I would really prefer to enable this button, and hide the loading AFTER 
            the user clicks. Sadly, I cannot get onclick to work during prerendering.
        *@
        <button class="btn btn-primary" type="button" disabled>
            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
            Loading...
        </button>  
    }
    @if (PrettyError is not null)
    {
        <Error ErrorContent="PrettyError"></Error>
    }
    else if (Error is not null)
    {
        <p class="alert-danger p-2 my-2">@Error</p>
    }

</div>

@code {

    /// <summary>
    /// Set to 'true' if Link should be launched in "Fix token" mode
    /// </summary>
    [Parameter]
    public bool IsFixingToken { get; set; }

    private PlaidError? PrettyError { get; set; }

    private string? Error { get; set; }

    private bool IsReady => JS is Microsoft.JSInterop.WebAssembly.WebAssemblyJSRuntime;

    private IJSObjectReference? module;

    private async Task LaunchLink()
    {
        try
        {
            Error = null;
            PrettyError = null;

            // First, let's see if we already HAVE credentials!
            context.Credentials = await Http.GetFromJsonAsync<PlaidCredentials>("link/info");
            if (string.IsNullOrEmpty(context.Credentials?.AccessToken) || IsFixingToken)
            {
                // Step 1: Get link token from server
                var createresponse = await Http.GetAsync($"link/CreateLinkToken{(IsFixingToken?"?fix=true":"")}");
                if (!createresponse.IsSuccessStatusCode)
                    throw new ApplicationException(await createresponse.Content.ReadAsStringAsync());

                var link_token = await createresponse.Content.ReadFromJsonAsync<string>();   

                // Step 2: Get public token from Link via JS interop
                var result = await module!.InvokeAsync<string>("launch_link",link_token);

                if (result is null)
                    throw new ApplicationException("Calling link failed");

                var link_result = System.Text.Json.JsonSerializer.Deserialize<LinkResult>(result);

                if (link_result is null)
                    throw new ApplicationException("Failed to serialize link result");

                if (link_result.ok != true)
                {
                    // TODO: Create new PlaidErrorException which has a PlaidError as a payload
                    if (link_result.error is not null)
                    {
                        PrettyError = link_result.error;
                        throw new ApplicationException();
                    }
                    else
                        throw new ApplicationException($"Link aborted. Status: {link_result.metadata?.status ?? "none"}");
                }

                // Step 3: Send public token back to server, which will populate credentials
                var response = await Http.PostAsJsonAsync<LinkResult>("link/ExchangePublicToken",link_result);
                if (!response.IsSuccessStatusCode)
                    throw new ApplicationException(await response.Content.ReadAsStringAsync());

                context.Credentials = await response.Content.ReadFromJsonAsync<PlaidCredentials>();   
            }

            context.LinkSuccess = true;
            context.IsItemAccess = true;
        }
        catch (Exception ex)
        {
            // TODO: Prettier display of error information
            Error = $"Failed to Launch: {ex.GetType().Name}: {ex.Message}";
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {
            if (firstRender)
            {
                module = await JS.InvokeAsync<IJSObjectReference>("import", "./Components/Link.razor.js");                            
            }
        }
        catch (Exception ex)
        {
            Error = $"Failed to Load JS {ex.GetType().Name}: {ex.Message}";            
        }
    }
}
